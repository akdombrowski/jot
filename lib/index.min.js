import crypto from"crypto";export const jwtDecode=e=>{try{if(!e.includes("."))throw new Error("Need at least one '.'");const r=e.split("."),t=r[0],o=Buffer.from(t,"base64url").toString("utf8");if(!o)throw console.error("base64URLDecodedHeader"),console.error(o),new Error("Header isn't base64url encoded");const s=JSON.parse(o),{typ:a,cty:n,alg:i}=s;if(a&&"JWT"!==a)throw new Error(`Need to be type jwt. Received: ${a}`);if(n&&"JWT"!==n)throw new Error(`Need a cty of 'JWT'. Received: ${n}`);if(!i)throw new Error("Missing algorithm in JOSE header.");if(3===r.length){const e=r[1],t=Buffer.from(e,"base64url").toString("utf8");return{header:s,payload:JSON.parse(t),signature:r[2]}}throw new SyntaxError("Not using compact serialization (JWS).")}catch(e){throw e}};const debugging=e=>{console.error(e.message,e),console.error("e instanceof SyntaxError"),console.error(e instanceof SyntaxError),console.error(e.message),console.error(e.name),console.error(e.fileName),console.error(e.lineNumber),console.error(e.columnNumber),console.error(e.stack)};export const hs256Sign=(e,r)=>{const t=crypto.createSecretKey(r,"base64url"),o=crypto.createHmac("sha256",t);o.update(e,"ascii");const s=o.digest();return Buffer.from(s).toString("base64url")};export const rs256JWKSign=(e,r)=>{if(!crypto.getHashes().includes("RSA-SHA256"))throw console.error("RSA-SHA256 not found"),new Error("RSA-SHA256 isn't available in the current system.");{let t;try{try{t=JSON.parse(r)}catch(e){if(!JSON.stringify(r))throw new Error("Not valid JSON.");t=r}const o=crypto.createPrivateKey({key:t,format:"jwk"}),s=crypto.sign("sha256",Buffer.from(e),{key:o});return s.toString("base64url")}catch(e){if(!(e instanceof TypeError))throw console.error(e.message,e),e;t=r}}return null};export const rs256PEMSign=(e,r,t)=>{let o;if(!crypto.getHashes().includes("RSA-SHA256"))return console.error("RSA-SHA256 not found"),null;try{o=crypto.createPrivateKey({key:r,format:"pem"})}catch(e){if(!t)throw new Error("Can't create private key object. Possibly because the key is encrypted so a passphrase was needed but none was provided or it was malformed.",{cause:e});try{o=crypto.createPrivateKey({key:r,format:"pem",passphrase:t})}catch(e){throw new Error("Failed to create the private key object needed create the RS256 signature. Tried without and with a passphrase in case the ",{cause:e})}}return crypto.sign("sha256",Buffer.from(e),{key:o}).toString("base64url")};export const rs256JWKVerify=(e,r)=>{const t=e.split("."),o=t[0]+"."+t[1],s=t[2],a=crypto.createPublicKey({key:r,format:"jwk"});return crypto.verify(null,Buffer.from(o,"ascii"),{key:a},Buffer.from(s,"base64url"))};export const rs256PEMVerify=(e,r)=>{const t=e.split("."),o=t[0]+"."+t[1],s=t[2],a=crypto.createPublicKey({key:r,format:"pem"});return crypto.verify(null,Buffer.from(o,"ascii"),{key:a},Buffer.from(s,"base64url"))};export const hs256Verify=(e,r,t)=>{const o=e.split("."),s=o[0]+"."+o[1],a=o[2];let n=crypto.createSecretKey(r,"base64url");n=t&&Buffer.isEncoding(t)?crypto.createSecretKey(r,t):crypto.createSecretKey(r,"base64url");const i=crypto.createHmac("sha256",n);i.update(s,"ascii");const c=i.digest();return Buffer.from(c).toString("base64url")===a};export const createHeaderPayload=(e,r)=>{if(Buffer.isEncoding("base64url")){let t,o;if("string"==typeof e)t=Buffer.from(e,"ascii").toString("base64url");else{const r=parseToJSON(e);t=base64URLEncode(JSON.stringify(r))}if("string"==typeof r)o=Buffer.from(r,"ascii").toString("base64url");else{const e=parseToJSON(r);o=base64URLEncode(JSON.stringify(e))}return`${t}.${o}`}throw new Error("Error: Base64URL encoding isn't available.")};export const base64URLEncode=e=>{if(Buffer.isEncoding("base64url")){return Buffer.from(e,"ascii").toString("base64url")}if(window){let r=window.btoa()(e).split("=")[0];return r=r.replace("+","-"),r=r.replace("/","_"),r}throw new Error("Error: Base64URL encoding isn't available")};export const parseToJSON=e=>{let r=e;if(Buffer.isEncoding("base64url"))return r=e instanceof Object?e:JSON.parse(e),r;throw new Error("Error: Base64URL encoding isn't available")};export const jwtEncode=(e,r,t,o)=>{let s,a=e;if(Buffer.isEncoding("base64url")){if(e instanceof Object){a=e;const r=JSON.stringify(e);s=Buffer.from(r,"ascii").toString("base64url")}else a=JSON.parse(e),s=Buffer.from(e,"ascii").toString("base64url");const n=createHeaderPayload(e,r),{alg:i}=a;let c;if(i){switch(i.toLowerCase()){case"hs256":c=hs256Sign(n,t);break;case"rs256":if(!o||!o.keyFormat)throw new Error("Need to specify keyFormat in options for RS256 algorithm as either jwk or pem.");{const e=o.keyFormat;"jwk"===e.toLowerCase()?c=rs256JWKSign(n,t):"pem"===e.toLowerCase()&&(c=o.passphrase?rs256PEMSign(n,t,o.passphrase):rs256PEMSign(n,t))}break;default:throw new Error(`Unsupported alg: ${i}`)}return n+"."+c}throw new Error("Algorithm couldn't be determined. alg:"+i)}throw new Error("Error: Base64URL encoding isn't available.")};export default jwtDecode;