"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rs256PEMVerify=exports.rs256PEMSign=exports.rs256JWKVerify=exports.rs256JWKSign=exports.parseToJSON=exports.jwtEncode=exports.jwtDecode=exports.hs256Verify=exports.hs256Sign=exports.default=exports.createHeaderPayload=exports.base64URLEncode=void 0;var _crypto=_interopRequireDefault(require("crypto"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}var jwtDecode=e=>{try{if(!e.includes("."))throw new Error("Need at least one '.'");var r=e.split("."),t=r[0],a=Buffer.from(t,"base64url").toString("utf8");if(!a)throw console.error("base64URLDecodedHeader"),console.error(a),new Error("Header isn't base64url encoded");var o=JSON.parse(a),{typ:s,cty:i,alg:n}=o;if(s&&"JWT"!==s)throw new Error("Need to be type jwt. Received: ".concat(s));if(i&&"JWT"!==i)throw new Error("Need a cty of 'JWT'. Received: ".concat(i));if(!n)throw new Error("Missing algorithm in JOSE header.");if(3===r.length){var c=r[1],f=Buffer.from(c,"base64url").toString("utf8");return{header:o,payload:JSON.parse(f),signature:r[2]}}throw new SyntaxError("Not using compact serialization (JWS).")}catch(e){throw e}};exports.jwtDecode=jwtDecode;var debugging=e=>{console.error(e.message,e),console.error("e instanceof SyntaxError"),console.error(e instanceof SyntaxError),console.error(e.message),console.error(e.name),console.error(e.fileName),console.error(e.lineNumber),console.error(e.columnNumber),console.error(e.stack)},hs256Sign=(e,r)=>{var t=_crypto.default.createSecretKey(r,"base64url"),a=_crypto.default.createHmac("sha256",t);a.update(e,"ascii");var o=a.digest();return Buffer.from(o).toString("base64url")};exports.hs256Sign=hs256Sign;var rs256JWKSign=(e,r)=>{var t;if(!_crypto.default.getHashes().includes("RSA-SHA256"))throw console.error("RSA-SHA256 not found"),new Error("RSA-SHA256 isn't available in the current system.");try{try{t=JSON.parse(r)}catch(e){if(!JSON.stringify(r))throw new Error("Not valid JSON.");t=r}var a=_crypto.default.createPrivateKey({key:t,format:"jwk"});return _crypto.default.sign("sha256",Buffer.from(e),{key:a}).toString("base64url")}catch(e){if(!(e instanceof TypeError))throw console.error(e.message,e),e;t=r}return null};exports.rs256JWKSign=rs256JWKSign;var rs256PEMSign=(e,r,t)=>{var a;if(!_crypto.default.getHashes().includes("RSA-SHA256"))return console.error("RSA-SHA256 not found"),null;try{a=_crypto.default.createPrivateKey({key:r,format:"pem"})}catch(e){if(!t)throw new Error("Can't create private key object. Possibly because the key is encrypted so a passphrase was needed but none was provided or it was malformed.",{cause:e});try{a=_crypto.default.createPrivateKey({key:r,format:"pem",passphrase:t})}catch(e){throw new Error("Failed to create the private key object needed create the RS256 signature. Tried without and with a passphrase in case the ",{cause:e})}}return _crypto.default.sign("sha256",Buffer.from(e),{key:a}).toString("base64url")};exports.rs256PEMSign=rs256PEMSign;var rs256JWKVerify=(e,r)=>{var t=e.split("."),a=t[0]+"."+t[1],o=t[2],s=_crypto.default.createPublicKey({key:r,format:"jwk"});return _crypto.default.verify(null,Buffer.from(a,"ascii"),{key:s},Buffer.from(o,"base64url"))};exports.rs256JWKVerify=rs256JWKVerify;var rs256PEMVerify=(e,r)=>{var t=e.split("."),a=t[0]+"."+t[1],o=t[2],s=_crypto.default.createPublicKey({key:r,format:"pem"});return _crypto.default.verify(null,Buffer.from(a,"ascii"),{key:s},Buffer.from(o,"base64url"))};exports.rs256PEMVerify=rs256PEMVerify;var hs256Verify=(e,r,t)=>{var a=e.split("."),o=a[0]+"."+a[1],s=a[2],i=_crypto.default.createSecretKey(r,"base64url");i=t&&Buffer.isEncoding(t)?_crypto.default.createSecretKey(r,t):_crypto.default.createSecretKey(r,"base64url");var n=_crypto.default.createHmac("sha256",i);n.update(o,"ascii");var c=n.digest();return Buffer.from(c).toString("base64url")===s};exports.hs256Verify=hs256Verify;var createHeaderPayload=(e,r)=>{if(Buffer.isEncoding("base64url")){var t,a;if("string"==typeof e)t=Buffer.from(e,"ascii").toString("base64url");else{var o=parseToJSON(e);t=base64URLEncode(JSON.stringify(o))}if("string"==typeof r)a=Buffer.from(r,"ascii").toString("base64url");else{var s=parseToJSON(r);a=base64URLEncode(JSON.stringify(s))}return"".concat(t,".").concat(a)}throw new Error("Error: Base64URL encoding isn't available.")};exports.createHeaderPayload=createHeaderPayload;var base64URLEncode=e=>{if(Buffer.isEncoding("base64url"))return Buffer.from(e,"ascii").toString("base64url");if(window){var r=window.btoa()(e).split("=")[0];return r=(r=r.replace("+","-")).replace("/","_")}throw new Error("Error: Base64URL encoding isn't available")};exports.base64URLEncode=base64URLEncode;var parseToJSON=e=>{if(Buffer.isEncoding("base64url"))return e instanceof Object?e:JSON.parse(e);throw new Error("Error: Base64URL encoding isn't available")};exports.parseToJSON=parseToJSON;var jwtEncode=(e,r,t,a)=>{var o=e;if(Buffer.isEncoding("base64url")){if(e instanceof Object){o=e;var s=JSON.stringify(e);Buffer.from(s,"ascii").toString("base64url")}else o=JSON.parse(e),Buffer.from(e,"ascii").toString("base64url");var i,n=createHeaderPayload(e,r),{alg:c}=o;if(c){switch(c.toLowerCase()){case"hs256":i=hs256Sign(n,t);break;case"rs256":if(!a||!a.keyFormat)throw new Error("Need to specify keyFormat in options for RS256 algorithm as either jwk or pem.");var f=a.keyFormat;"jwk"===f.toLowerCase()?i=rs256JWKSign(n,t):"pem"===f.toLowerCase()&&(i=a.passphrase?rs256PEMSign(n,t,a.passphrase):rs256PEMSign(n,t));break;default:throw new Error("Unsupported alg: ".concat(c))}return n+"."+i}throw new Error("Algorithm couldn't be determined. alg:"+c)}throw new Error("Error: Base64URL encoding isn't available.")};exports.jwtEncode=jwtEncode;var _default=exports.default=jwtDecode;