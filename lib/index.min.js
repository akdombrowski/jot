"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.jwtEncode=exports.parseToJSON=exports.base64URLEncode=exports.createHeaderPayload=exports.hs256Verify=exports.rs256PEMVerify=exports.rs256JWKVerify=exports.rs256PEMSign=exports.rs256JWKSign=exports.hs256Sign=exports.jwtDecode=void 0;var _crypto=_interopRequireDefault(require("crypto")),jwtDecode=function(r){try{if(!r.includes("."))throw new Error("Need at least one '.'");var e=r.split("."),t=e[0],o=Buffer.from(t,"base64url").toString("utf8");if(!o)throw console.error("base64URLDecodedHeader"),console.error(o),new Error("Header isn't base64url encoded");var a=JSON.parse(o),s=a.typ,n=a.cty,i=a.alg;if(s&&"JWT"!==s)throw new Error("Need to be type jwt. Received: ".concat(s));if(n&&"JWT"!==n)throw new Error("Need a cty of 'JWT'. Received: ".concat(n));if(!i)throw new Error("Missing algorithm in JOSE header.");if(3===e.length){var c=e[1],f=Buffer.from(c,"base64url").toString("utf8");return{header:a,payload:JSON.parse(f),signature:e[2]}}throw new SyntaxError("Not using compact serialization (JWS).")}catch(r){throw r}};exports.jwtDecode=jwtDecode;var debugging=function(r){console.error(r.message,r),console.error("e instanceof SyntaxError"),console.error(r instanceof SyntaxError),console.error(r.message),console.error(r.name),console.error(r.fileName),console.error(r.lineNumber),console.error(r.columnNumber),console.error(r.stack)},hs256Sign=function(r,e){var t=_crypto.default.createSecretKey(e,"base64url"),o=_crypto.default.createHmac("sha256",t);o.update(r,"ascii");var a=o.digest();return Buffer.from(a).toString("base64url")};exports.hs256Sign=hs256Sign;var rs256JWKSign=function(r,e){var t;if(!_crypto.default.getHashes().includes("RSA-SHA256"))throw console.error("RSA-SHA256 not found"),new Error("RSA-SHA256 isn't available in the current system.");try{try{t=JSON.parse(e)}catch(r){if(!JSON.stringify(e))throw new Error("Not valid JSON.");t=e}var o=_crypto.default.createPrivateKey({key:t,format:"jwk"});return _crypto.default.sign("sha256",Buffer.from(r),{key:o}).toString("base64url")}catch(r){if(!(r instanceof TypeError))throw console.error(r.message,r),r;t=e}return null};exports.rs256JWKSign=rs256JWKSign;var rs256PEMSign=function(r,e,t){var o;if(!_crypto.default.getHashes().includes("RSA-SHA256"))return console.error("RSA-SHA256 not found"),null;try{o=_crypto.default.createPrivateKey({key:e,format:"pem"})}catch(r){if(r instanceof TypeError&&r.message.includes("Passphrase required for encrypted key")){if(!t)throw new Error("Need a passphrase since private key is encrypted");o=_crypto.default.createPrivateKey({key:e,format:"pem",passphrase:t})}}return _crypto.default.sign("sha256",Buffer.from(r),{key:o}).toString("base64url")};exports.rs256PEMSign=rs256PEMSign;var rs256JWKVerify=function(r,e){var t=r.split("."),o=t[0]+"."+t[1],a=t[2],s=_crypto.default.createPublicKey({key:e,format:"jwk"});return _crypto.default.verify(null,Buffer.from(o,"ascii"),{key:s},Buffer.from(a,"base64url"))};exports.rs256JWKVerify=rs256JWKVerify;var rs256PEMVerify=function(r,e){var t=r.split("."),o=t[0]+"."+t[1],a=t[2],s=_crypto.default.createPublicKey({key:e,format:"pem"});return _crypto.default.verify(null,Buffer.from(o,"ascii"),{key:s},Buffer.from(a,"base64url"))};exports.rs256PEMVerify=rs256PEMVerify;var hs256Verify=function(r,e,t){var o=r.split("."),a=o[0]+"."+o[1],s=o[2],n=_crypto.default.createSecretKey(e,"base64url");n=t&&Buffer.isEncoding(t)?_crypto.default.createSecretKey(e,t):_crypto.default.createSecretKey(e,"base64url");var i=_crypto.default.createHmac("sha256",n);i.update(a,"ascii");var c=i.digest();return Buffer.from(c).toString("base64url")===s};exports.hs256Verify=hs256Verify;var createHeaderPayload=function(r,e){if(Buffer.isEncoding("base64url")){var t,o;if("string"==typeof r)t=Buffer.from(r,"ascii").toString("base64url");else{var a=parseToJSON(r);t=base64URLEncode(JSON.stringify(a))}if("string"==typeof e)o=Buffer.from(e,"ascii").toString("base64url");else{var s=parseToJSON(e);o=base64URLEncode(JSON.stringify(s))}return"".concat(t,".").concat(o)}throw new Error("Error: Base64URL encoding isn't available.")};exports.createHeaderPayload=createHeaderPayload;var base64URLEncode=function(r){if(Buffer.isEncoding("base64url"))return Buffer.from(r,"ascii").toString("base64url");if(window){var e=window.btoa()(r).split("=")[0];return e=(e=e.replace("+","-")).replace("/","_")}throw new Error("Error: Base64URL encoding isn't available")};exports.base64URLEncode=base64URLEncode;var parseToJSON=function(r){if(Buffer.isEncoding("base64url"))return r instanceof Object?r:JSON.parse(r);throw new Error("Error: Base64URL encoding isn't available")};exports.parseToJSON=parseToJSON;var jwtEncode=function(r,e,t,o){var a=r;if(Buffer.isEncoding("base64url")){if(r instanceof Object){a=r;var s=JSON.stringify(r);Buffer.from(s,"ascii").toString("base64url")}else a=JSON.parse(r),Buffer.from(r,"ascii").toString("base64url");var n,i=createHeaderPayload(r,e),c=a.alg;if(c){switch(c.toLowerCase()){case"hs256":n=hs256Sign(i,t);break;case"rs256":if(!o||!o.keyFormat)throw new Error("Need to specify keyFormat in options for RS256 algorithm as either jwk or pem.");var f=o.keyFormat;"jwk"===f.toLowerCase()?n=rs256JWKSign(i,t):"pem"===f.toLowerCase()&&(n=o.passphrase?rs256PEMSign(i,t,o.passphrase):rs256PEMSign(i,t));break;default:throw new Error("Unsupported alg: ".concat(c))}return i+"."+n}throw new Error("Algorithm couldn't be determined. alg:"+c)}throw new Error("Error: Base64URL encoding isn't available.")};exports.jwtEncode=jwtEncode;var _default=jwtDecode;exports.default=_default;
