import crypto from"crypto";export const jwtDecode=jwt=>{try{if(!jwt.includes("."))throw new Error("Need at least one '.'");const components=jwt.split("."),header=components[0],base64URLDecodedHeader=Buffer.from(header,"base64url").toString("utf8");if(!base64URLDecodedHeader)throw console.err("base64URLDecodedHeader"),console.err(base64URLDecodedHeader),new Error("Header isn't base64url encoded");const jsonHeader=JSON.parse(base64URLDecodedHeader),{typ:typ,cty:cty,alg:alg}=jsonHeader;if(typ&&"JWT"!==typ)throw new Error(`Need to be type jwt. Received: ${typ}`);if(cty&&"JWT"!==cty)throw new Error(`Need a cty of 'JWT'. Received: ${cty}`);if(!alg)throw new Error("Missing algorithm in JOSE header.");if(3===components.length){const payload=components[1],base64urlDecodedPayload=Buffer.from(payload,"base64url").toString("utf8"),jsonPayload=JSON.parse(base64urlDecodedPayload);return{header:jsonHeader,payload:jsonPayload,signature:components[2]}}throw new Error("Not using compact serialization (JWS).")}catch(e){return console.error(e.message,e),{header:null,payload:null,signature:null}}};export const hs256Sign=(headerPayload,key)=>{const secret=crypto.createSecretKey(key,"base64url"),hmac=crypto.createHmac("sha256",secret);hmac.update(headerPayload,"ascii");const hmacked=hmac.digest(),base64URLHmacked=Buffer.from(hmacked).toString("base64url");return base64URLHmacked};export const rs256JWKSign=(headerPayload,privateKey)=>{const hashes=crypto.getHashes();if(!hashes.includes("RSA-SHA256"))throw console.error("RSA-SHA256 not found"),new Error("RSA-SHA256 isn't available in the current system.");{let secret;try{try{secret=JSON.parse(privateKey)}catch(e){if(!JSON.stringify(privateKey))throw new Error("Not valid JSON.");secret=privateKey}const keyObject=crypto.createPrivateKey({key:secret,format:"jwk"}),sig=crypto.sign("sha256",Buffer.from(headerPayload),{key:keyObject}),sigBase64URL=sig.toString("base64url");return sigBase64URL}catch(e){e instanceof TypeError?secret=privateKey:console.error(e.message,e)}}return null};export const rs256PEMSign=(headerPayload,privateKey,passphrase)=>{const hashes=crypto.getHashes();let pemKey;if(!hashes.includes("RSA-SHA256"))return console.error("RSA-SHA256 not found"),null;try{pemKey=crypto.createPrivateKey({key:privateKey,format:"pem"})}catch(e){if(e instanceof TypeError&&e.message.includes("Passphrase required for encrypted key")){if(!passphrase)throw new Error("Need a passphrase since private key is encrypted");pemKey=crypto.createPrivateKey({key:privateKey,format:"pem",passphrase:passphrase})}}const sig=crypto.sign("sha256",Buffer.from(headerPayload),{key:pemKey}),sigBase64URL=sig.toString("base64url");return sigBase64URL};export const rs256JWKVerify=(jwt,publicKey)=>{const jwtComponents=jwt.split("."),headerPayload=jwtComponents[0]+"."+jwtComponents[1],signature=jwtComponents[2],keyObject=crypto.createPublicKey({key:publicKey,format:"jwk"}),isVerified=crypto.verify(null,Buffer.from(headerPayload,"ascii"),{key:keyObject},Buffer.from(signature,"base64url"));return isVerified};export const rs256PEMVerify=(jwt,publicKey)=>{const jwtComponents=jwt.split("."),headerPayload=jwtComponents[0]+"."+jwtComponents[1],signature=jwtComponents[2],keyObject=crypto.createPublicKey({key:publicKey,format:"pem"}),isVerified=crypto.verify(null,Buffer.from(headerPayload,"ascii"),{key:keyObject},Buffer.from(signature,"base64url"));return isVerified};export const hs256Verify=(jwt,passphrase,passphraseEncoding)=>{const jwtComponents=jwt.split("."),headerPayload=jwtComponents[0]+"."+jwtComponents[1],signature=jwtComponents[2];let secret=crypto.createSecretKey(passphrase,"base64url");secret=passphraseEncoding&&Buffer.isEncoding(passphraseEncoding)?crypto.createSecretKey(passphrase,passphraseEncoding):crypto.createSecretKey(passphrase,"base64url");const hmac=crypto.createHmac("sha256",secret);hmac.update(headerPayload,"ascii");const hmacked=hmac.digest(),base64URLHmacked=Buffer.from(hmacked).toString("base64url"),isVerified=base64URLHmacked===signature;return isVerified};export const createHeaderPayload=(header,payload)=>{if(Buffer.isEncoding("base64url")){let headerBase64URL,payloadBase64URL;if("string"==typeof header)headerBase64URL=Buffer.from(header,"ascii").toString("base64url");else{const jsonHeader=parseToJSON(header);headerBase64URL=base64URLEncode(jsonHeader)}if("string"==typeof payload)payloadBase64URL=Buffer.from(payload,"ascii").toString("base64url");else{const jsonPayload=parseToJSON(payload);payloadBase64URL=base64URLEncode(jsonPayload)}const headerPayload=`${headerBase64URL}.${payloadBase64URL}`;return headerPayload}throw new Error("Error: Base64URL encoding isn't available.")};export const base64URLEncode=jsonObject=>{if(Buffer.isEncoding("base64url")){const stringifyHeader=JSON.stringify(jsonObject),payloadBase64URL=Buffer.from(stringifyHeader,"ascii").toString("base64url");return payloadBase64URL}throw new Error("Error: Base64URL encoding isn't available")};export const parseToJSON=input=>{let json=input;if(Buffer.isEncoding("base64url"))return json=input instanceof Object?input:JSON.parse(input),json;throw new Error("Error: Base64URL encoding isn't available")};export const jwtEncode=(header,payload,key,options)=>{let headerBase64URL,payloadBase64URL,jsonHeader=header;if(Buffer.isEncoding("base64url")){if(header instanceof Object){jsonHeader=header;const stringifyHeader=JSON.stringify(header);headerBase64URL=Buffer.from(stringifyHeader,"ascii").toString("base64url")}else jsonHeader=JSON.parse(header),headerBase64URL=Buffer.from(header,"ascii").toString("base64url");const headerPayload=createHeaderPayload(header,payload),{alg:alg}=jsonHeader;let sig;if(alg){switch(alg.toLowerCase()){case"hs256":sig=hs256Sign(headerPayload,key);break;case"rs256":if(!options||!options.keyFormat)throw new Error("Need to specify keyFormat in options for RS256 algorithm as either jwk or pem.");{const keyFormat=options.keyFormat;"jwk"===keyFormat.toLowerCase()?sig=rs256JWKSign(headerPayload,key):"pem"===keyFormat.toLowerCase()&&(sig=options.passphrase?rs256PEMSign(headerPayload,key,options.passphrase):rs256PEMSign(headerPayload,key))}break;default:throw new Error(`Unsupported alg: ${alg}`)}return headerPayload+"."+sig}throw new Error("Algorithm couldn't be determined. alg:"+alg)}throw new Error("Error: Base64URL encoding isn't available.")};export default jwtDecode;